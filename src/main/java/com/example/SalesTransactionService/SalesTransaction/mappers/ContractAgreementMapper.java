package com.example.SalesTransactionService.SalesTransaction.mappers;
import com.example.SalesTransactionService.SalesTransaction.dtos.RequestDto.ContractAgreementRequestDto;
import com.example.SalesTransactionService.SalesTransaction.dtos.RequestDto.ItemDetailRequestDto;
import com.example.SalesTransactionService.SalesTransaction.dtos.RequestDto.WitnessInformationRequestDto;
import com.example.SalesTransactionService.SalesTransaction.dtos.ResponseDto.ContractAgreementRegistrationResponseDto;
import com.example.SalesTransactionService.SalesTransaction.models.AgreementRegistration.ContractAgreementRegistration;
import com.example.SalesTransactionService.SalesTransaction.models.AgreementRegistration.ItemDetail;
import com.example.SalesTransactionService.SalesTransaction.models.AgreementRegistration.WitnessInformation;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.stream.Collectors;

// Ensure this mapper knows about other mappers for nested objects
@Mapper(componentModel = "spring", uses = {ItemDetailMapper.class, WitnessInformationMapper.class})
public interface ContractAgreementMapper {

    ContractAgreementMapper INSTANCE = Mappers.getMapper(ContractAgreementMapper.class);

    // --- Request DTO to Entity Mapping ---
    @Mapping(target = "id", ignore = true) // ID is generated by DB on creation
    @Mapping(target = "customer", ignore = true) // Customer will be set by service based on customerId
    @Mapping(target = "itemServiceDetails", ignore = true) // Handled by service or helper method
    @Mapping(target = "witnessInformation", ignore = true) // Handled by service or helper method
    ContractAgreementRegistration toEntity(ContractAgreementRequestDto dto);

    // --- Entity to Response DTO Mapping ---
    @Mapping(source = "customer.id", target = "customerId") // Flatten customer ID
    // Map the nested lists automatically if ItemServiceDetailMapper and WitnessInformationMapper are used
    ContractAgreementRegistrationResponseDto toResponseDto(ContractAgreementRegistration entity);

    // --- Update Entity from DTO ---
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "customer", ignore = true)
    @Mapping(target = "itemServiceDetails", ignore = true) // Will be handled by service
    @Mapping(target = "witnessInformation", ignore = true) // Will be handled by service
    void updateEntityFromDto(ContractAgreementRequestDto dto, @MappingTarget ContractAgreementRegistration entity);

    // Helper method for setting bidirectional relationship on creation/update for lists
    // This part is often best handled in the service layer due to needing to fetch existing entities.
    // However, for simple cases, you can define it here.
    @Named("mapItemsToContract")
    default List<ItemDetail> mapItemsToContract(List<ItemDetailRequestDto> dtos, ContractAgreementRegistration contract) {
        if (dtos == null) return null;
        return dtos.stream().map(dto -> {
            ItemDetail item = Mappers.getMapper(ItemDetailMapper.class).toEntity(dto);
            item.setContractAgreement(contract);
            return item;
        }).collect(Collectors.toList());
    }

    @Named("mapWitnessesToContract")
    default List<WitnessInformation> mapWitnessesToContract(List<WitnessInformationRequestDto> dtos, ContractAgreementRegistration contract) {
        if (dtos == null) return null;
        return dtos.stream().map(dto -> {
            WitnessInformation witness = Mappers.getMapper(WitnessInformationMapper.class).toEntity(dto);
            witness.setContractAgreement(contract);
            return witness;
        }).collect(Collectors.toList());
    }
}